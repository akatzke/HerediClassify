#+title: Mermaid

* General information
Code for visualising software design in mermaid
* Variant classification overview
#+begin_src mermaid :file overview.png
flowchart LR
    DB[(Database)] -->|Import| RD[Raw data]
    CR["Configuration
   rules"] --> CIR{"Configuration import
   rules"}
    C["Configuration"] --> CI{"Configuration import"}
    CL --> |Export| Output
    subgraph Variant_classification_tool
    RD -->DP{Data processing}
    DP --> PD[Processed data]
    CIR --> PL[Data process list]
    CIR --> RL[Rule list]
    PL --> DP
    PD --> CL{Classification}
    RL --> CL
    CI --> T[Thresholds]
    T --> DP
    end
#+end_src

#+RESULTS:
[[file:overview.png]]
* Configuration import
#+begin_src mermaid :file configuration_import_rules.png
flowchart LR
    CF[Configuration file] -->I{import}
    CS --> RE[Error]
    FR --> DPL["Data processing
    set"]
    FR --> RL[Rule set]
    subgraph Configuration_import
    I --> C[Configuration]
    C --> FR{find_rule_in_dict}
    RD[Rule dictionary] -->FR
    FR --> IS{insert_into_set}
    IS --> CS{check_set}
    end
#+end_src
* Prediction tools
** Prediction tools refactored
#+begin_src mermaid :file predicition_tool.png
flowchart LR
   T[threshold] --> GP{get_prediction}
   D[data] --> GP
   TL[tool_list] --> GP
   PT[prediction_type] --> GP
   subgraph prediction_tools
       GP --> 1T{assess_one_threshold}
       GP --> 2T{assess_two_threshold}
       GP --> APR["aggregate prediction
       results"]
       end
#+end_src

#+RESULTS:
[[file:predicition_tool_refactored.png]]
** GenOtoScope
Decision on what prediction tool is to be used is based on variant type
Exonic variants only get pathogenictiy scores and conservation
Intronic and synonymous variants get
#+begin_src mermaid :file prediction_tool_genotoscope.png
flowchart LR
   VT["variant type
   exonic, intronic
   or synonymous"] --> GP{get_prediction}
   T[threshold] --> GP
   APP -->ER["exonic result"]
   VC --> ER
   APP --> IR["intronic result"]
   ASP -->IR
   VC --> IR
   APP --> SR["synonymous result"]
   VC --> SR
   ASP --> SR
   subgraph assess_pp3_bp4
       GP -->|exonic & intronic| VP{is_variant_pathogenic}
       GP -->|exonic & intronic| VC{is_variant_conserved}
       VP -->APP{aggregate_patho_prediction}
       GP -->|intronic| PMP{"parse_maxentscan_pred"}
       GP -->|intronic| PDP{"parse_dbscsnv_pred"}
       PMP -->ASP{aggregate_splicing_prediction}
       PDP -->ASP
       end
#+end_src

#+RESULTS:
[[file:prediction_tool_genotoscope.png]]
* PM1
Information needed: variant information, transcripts, critical region, hotspot, critical protein regions without bening variants
Generally regions applicable to PMs for missense variants
#+begin_src mermaid :file critical_region_refactored.png
flowchart LR
   D[data] --> CR{check_critical_region}
   CR --> R[Result]
  subgraph assess_critical_region
      CR --> SCR{check_specific_critical_region}
      CR --> GCR{check_general_critical_region}
      end
#+end_src

#+RESULTS:
[[file:critical_region_refactored.png]]

Generally the files used for this annotation should at best contain genomic location
In taht case the whole transcript issue can be disregarde
Making the annotation a whole lot easier
Outsource the difficutl task elsewhere
#+begin_src mermaid :file annotate_critical_region.png
flowchart LR
   FL[file_location] --> ACR{annotated_critical_regions}
   VD[variant_data] --> ACR
   ACR --> AVD[annotated_variant_data]
   subgraph annotate_critical_region
       ACR --> IV{intersect_file_with_variant}
       IV --> CS{check_strand}
       end
#+end_src

#+RESULTS:
[[file:annotate_critical_region.png]]
* PVS1
Information needed: sequence of variant
Transcripts affected by variant
#+begin_src mermaid :file pvs1.png
flowchart LR

#+end_src
** Annotate for PVS1 and related
1. Sequence per transcript
2. Alternative start codons
3. Prediction of NMD
4. Assess exon skipping
5. Truncated exon significance
6. Protein length change
7. Premature termination codon
*** Assess_exon_skipping
Only for intronic variants
Needs part of the HGVS nomenclature
Will have to figure out what part exactly
Exon skipping automatically assumed when intron offset is 1 or 2
#+begin_src mermaid :file assess_exon_skipping.png
flowchart LR
   TI[transcript_id] --> gprt{get_pyensembl_reference_transcript}
   VP[variant_position] --> fae
   HGVS[HGVS_nomenclature] --> IP{parse_variant_intron_pos}
   subgraph check_if_exon_skipping_applies
       IP --> CIP{check_intron_offset}
       CIP --> |1 or 2| fae{find_affected_exon}
       subgraph get_affected_exon
           gprt --> rt[reference_transcript]
            rt --> gpae{get_position_of_all_exons}
           fae --> cae{characterise_affected_exons}
           gpae --> fae
           end
       end
#+end_src

#+RESULTS:
[[file:assess_exon_skipping.png]]

*** Sequence
#+begin_src mermaid :file reconstruct_variant_coding_sequence_coding_variant.png
flowchart LR
   VP[variant_position] --> GIO{get_intron_offset}
   TI[transcript_id] --> RTS{pyensembl.transcript_coding_sequence}
   VT[variant_type] --> GSC{get_start_codon}
   subgraph reconstruct_variant_coding_sequence
       GSC --> SaC[start_codon]
       GSC --> SoC[stop_codon]
       GIO --> IO[intron_offset]
       VT --> rsvt{reconstruct_sequence_according_to_variant_type}
       rsvt --> snp{reconstruct_sequence_snp}
       rsvt --> delins{reconstruct_sequence_delins}
       rsvt --> del{reconstruct_sequence_del}
       rsvt --> ins{reconstruct_sequence_ins}
       rsvt --> dup{reconstruct_sequence_dup}
       RTS --> rsvt
       end
#+end_src

#+begin_src mermaid :file reconstruct_variant_coding_sequence_intronic_variant.png
flowchart LR
   ti[transcript_id] --> rvs{reconstruct_variant_coding_sequence}
   es[exons_skipped] --> rvs
   tes[type_exons_skipped] --> rvs
#+end_src

#+RESULTS:
[[file:reconstruct_variant_coding_sequence.png]]

*** Protein length change
*** Prediction NMD
Gets transcript info and variant info
*** Premature termination codon
*** Alternative start codons
Generate list of all known start_codons
This information is extracted from the alternative transcripts
Using the pyensemble.transcript structure
#+begin_src mermaid :file alternative_start_codon.png
flowchart LR
   G[gene] --> GSC{get_start_codons}
   GSC --> DTS[dictionary_transcript_and_start_codon]
   subgraph get_alternative_start_codon
       GSC --> |Get all transcripts| PGT{pyensemble.gene.transcripts}
       GSC --> |Check if transcript is complete| PTC{pyensemble.transcript.complete}
       GSC --> |Get transcript start codon position| SCP{pyensemble.transcript.start_codon_positions}
       end
#+end_src

#+RESULTS:
[[file:alternative_start_codon.png]]

* Annotate ClinVar
Three separate columns will have to be generated
1. Same amino acid change in location
2. Different amino acid change in same location
3.
#+begin_src mermaid :file

#+end_src
* Refactoring
