#+title: Mermaid

* General information
Code for visualising software design in mermaid
* Variant classification overview
#+begin_src mermaid :file overview.png
flowchart LR
    DB[(Database)] -->|Import| RD[Raw data]
    CR["Configuration
   rules"] --> CIR{"Configuration import
   rules"}
    C["Configuration"] --> CI{"Configuration import"}
    CL --> |Export| Output
    subgraph Variant_classification_tool
    RD -->DP{Data processing}
    DP --> PD[Processed data]
    CIR --> PL[Data process list]
    CIR --> RL[Rule list]
    PL --> DP
    PD --> CL{Classification}
    RL --> CL
    CI --> T[Thresholds]
    T --> DP
    end
#+end_src
* Configuration import
#+begin_src mermaid :file configuration_import_rules.png
flowchart LR
    CF[Configuration file] -->I{import}
    CS --> RE[Error]
    FR --> DPL["Data processing
    set"]
    FR --> RL[Rule set]
    subgraph Configuration_import
    I --> C[Configuration]
    C --> FR{find_rule_in_dict}
    RD[Rule dictionary] -->FR
    FR --> IS{insert_into_set}
    IS --> CS{check_set}
    end
#+end_src
* Prediction tools
** Prediction tools refactored
#+begin_src mermaid :file predicition_tool.png
flowchart LR
   T[threshold] --> GP{get_prediction}
   D[data] --> GP
   TL[tool_list] --> GP
   PT[prediction_type] --> GP
   subgraph prediction_tools
       GP --> 1T{assess_one_threshold}
       GP --> 2T{assess_two_threshold}
       GP --> APR["aggregate prediction
       results"]
       end
#+end_src

#+RESULTS:
[[file:predicition_tool_refactored.png]]
** GenOtoScope
Decision on what prediction tool is to be used is based on variant type
Exonic variants only get pathogenictiy scores and conservation
Intronic and synonymous variants get
#+begin_src mermaid :file prediction_tool_genotoscope.png
flowchart LR
   VT["variant type
   exonic, intronic
   or synonymous"] --> GP{get_prediction}
   T[threshold] --> GP
   APP -->ER["exonic result"]
   VC --> ER
   APP --> IR["intronic result"]
   ASP -->IR
   VC --> IR
   APP --> SR["synonymous result"]
   VC --> SR
   ASP --> SR
   subgraph assess_pp3_bp4
       GP -->|exonic & intronic| VP{is_variant_pathogenic}
       GP -->|exonic & intronic| VC{is_variant_conserved}
       VP -->APP{aggregate_patho_prediction}
       GP -->|intronic| PMP{"parse_maxentscan_pred"}
       GP -->|intronic| PDP{"parse_dbscsnv_pred"}
       PMP -->ASP{aggregate_splicing_prediction}
       PDP -->ASP
       end
#+end_src

#+RESULTS:
[[file:prediction_tool_genotoscope.png]]
* PM1
Information needed: variant information, transcripts, critical region, hotspot, critical protein regions without bening variants
Generally regions applicable to PMs for missense variants
#+begin_src mermaid :file critical_region_refactored.png
flowchart LR
   D[data] --> CR{check_critical_region}
   CR --> R[Result]
  subgraph assess_critical_region
      CR --> SCR{check_specific_critical_region}
      CR --> GCR{check_general_critical_region}
      end
#+end_src

#+RESULTS:
[[file:critical_region_refactored.png]]

Generally the files used for this annotation should at best contain genomic location
In taht case the whole transcript issue can be disregarde
Making the annotation a whole lot easier
Outsource the difficutl task elsewhere
#+begin_src mermaid :file annotate_critical_region.png
flowchart LR
   FL[file_location] --> ACR{annotated_critical_regions}
   VD[variant_data] --> ACR
   ACR --> AVD[annotated_variant_data]
   subgraph annotate_critical_region
       ACR --> IV{intersect_file_with_variant}
       IV --> CS{check_strand}
       end
#+end_src

#+RESULTS:
[[file:annotate_critical_region.png]]
* PVS1
Information needed: sequence of variant
Transcripts affected by variant
** Annotate for PVS1 and related
Don't try and separate all the functions and refactor them here
Instead to begin with simply move the whole bunch to the annotation portion
Here it should be clearly defined though what input is needed for all of the separate functions
1. Sequence per transcript
2. Alternative start codons
3. Prediction of NMD
4. Assess exon skipping
5. Truncated exon significance
6. Protein length change
7. Premature termination codon
*** Assess_exon_skipping
Only for intronic variants
Needs part of the HGVS nomenclature
Will have to figure out what part exactly
Exon skipping automatically assumed when intron offset is 1 or 2
#+begin_src mermaid :file assess_exon_skipping.png
flowchart LR
   TI[transcript_id] --> gprt{get_pyensembl_reference_transcript}
   VP[variant_position] --> fae
   HGVS[HGVS_nomenclature] --> IP{parse_variant_intron_pos}
   subgraph check_if_exon_skipping_applies
       IP --> CIP{check_intron_offset}
       CIP --> |1 or 2| fae{find_affected_exon}
       subgraph get_affected_exon
           gprt --> rt[reference_transcript]
            rt --> gpae{get_position_of_all_exons}
           fae --> cae{characterise_affected_exons}
           gpae --> fae
           end
       end
#+end_src

#+RESULTS:
[[file:assess_exon_skipping.png]]

*** Sequence
This will for now return sequence, skipped exons and difference in protein_length
#+begin_src mermaid :file reconstruct_variant_coding_sequence.png
flowchart LR
   ti[transcript_info] -> cvs{contrsuct_variant_coding_sequence}
   vp[variant_position] -> cvs
   cvs --> seq[sequence]
   cvs --> pld[percent_length_difference]
   csv --> es[exon_skipping]
   csv --> nes[exons_skipped]
   csv --> tes[types_exon_skipped]
#+end_src
#+RESULTS:
[[file:reconstruct_variant_coding_sequence.png]]

*** Prediction NMD
Gets transcript info and variant info
*** Premature termination codon
*** Alternative start codons
Generate list of all known start_codons
This information is extracted from the alternative transcripts
Using the pyensemble.transcript structure
#+begin_src mermaid :file alternative_start_codon.png
flowchart LR
   G[gene] --> GSC{get_start_codons}
   GSC --> DTS[dictionary_transcript_and_start_codon]
   subgraph get_alternative_start_codon
       GSC --> |Get all transcripts| PGT{pyensemble.gene.transcripts}
       GSC --> |Check if transcript is complete| PTC{pyensemble.transcript.complete}
       GSC --> |Get transcript start codon position| SCP{pyensemble.transcript.start_codon_positions}
       end
#+end_src

#+RESULTS:
[[file:alternative_start_codon.png]]
*** TODO Think on how I want to handle data types
Specifically the variant_info class and the dictionary used to transport variant information
Those I do not really want to be using for my work
Therefore, they'll have to be replaced and the code refactored in order for the code to work with the new data structures
Though that should very much be a second though
For the first implementation of the code there should be no thoughts on these data structures
* Annotate ClinVar
Three separate columns will have to be generated
1. Same amino acid change in location
2. Different amino acid change in same location
3.
#+begin_src mermaid :file

#+end_src
* Refactoring
* Transcripts_info
This is a dataframe created by Daminaos in which he is saving the information generated on transcript level for the different variants
- gene_name
  Gene name
  E.g. BRCA1
- transcript_id
  Transcript ID (shortened)
  E.g. ENST00000380152
- type_variant
  Is type list
  Most likely will only contain one item but can also contain multiple
  E.g. [missense_variant]
- exon
  contains exon with 2 numbers
  E.g. "exon11/27"
  What does that mean?
- var_coding
  Contains a hgvs_parser object
  This object describes the change to the variant that occurs
- var_seq
  Sequence of deletion or insertion as found in HGVS nomenclature
  Check if that is true
- var_protein
  Contains change in protein sequence
  E.g. "Lys1025Glu"
** TODO There seems to be an error in the construction of var_seq in case of delins
If I understand correctly del_seq has to always be empty
