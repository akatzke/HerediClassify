#+title: Mermaid

* General information
Code for visualising software design in mermaid
* Variant classification overview
#+begin_src mermaid :file overview.png
flowchart LR
    DB[(Database)] -->|Import| RD[Raw data]
    C["Configuration"] --> CI{"Configuration import"}
    CR["Configuration
   rules"] --> CIR{"Configuration import
   rules"}
    CL --> |Export| Output
    subgraph Variant_classification_tool
        CI --> T[Thresholds]
        RD -->DP{Data processing}
        DP --> PD[Processed data]
        CIR --> PL[Data process list]
        CIR --> RL[Rule list]
        PL --> DP
        PD --> CL{Classification}
        RL --> CL
        T --> DP
    end
#+end_src

#+RESULTS:
[[file:overview.png]]

* Configuration import
#+begin_src mermaid :file configuration_import_rules.png
flowchart LR
    CF[Configuration rules] -->I{import}
    CS --> RE[Error]
    FR --> DPL["Data processing
    set"]
    FR --> RL[Rule set]
    subgraph Configuration_import
        I --> C[Configuration]
        C --> FR{find_rule_in_dict}
        RD[Rule dictionary] -->FR
        FR --> IS{insert_into_set}
        IS --> CS{check_set}
        end
#+end_src

#+RESULTS:
[[file:configuration_import_rules.png]]
** Note
For the data processing the variant is important too
So for certain variant types some annotations are not necessary
E.g. the coding sequence reconstruction is only necessary for a subset of variants and very processing intensive
At this point in some manner the variant_type should be checked as well?
* Prediction tools
** Prediction tools refactored
#+begin_src mermaid :file predicition_tool.png
flowchart LR
   T[threshold] --> GP{get_prediction}
   D[data] --> GP
   TL[tool_list] --> GP
   PT[prediction_type] --> GP
   subgraph prediction_tools
       GP --> 1T{assess_one_threshold}
       GP --> 2T{assess_two_threshold}
       GP --> APR["aggregate prediction
       results"]
       end
    GP --> is_rule_applicable
    GP --> rule_comment
    GP --> rule_strength
#+end_src

#+RESULTS:
[[file:predicition_tool.png]]
** GenOtoScope
Decision on what prediction tool is to be used is based on variant type
Exonic variants only get pathogenictiy scores and conservation
Intronic and synonymous variants get
#+begin_src mermaid :file prediction_tool_genotoscope.png
flowchart LR
   VT["variant type
   exonic, intronic
   or synonymous"] --> GP{get_prediction}
   T[threshold] --> GP
   APP -->ER["exonic result"]
   VC --> ER
   APP --> IR["intronic result"]
   ASP -->IR
   VC --> IR
   APP --> SR["synonymous result"]
   VC --> SR
   ASP --> SR
   subgraph assess_pp3_bp4
       GP -->|exonic & intronic| VP{is_variant_pathogenic}
       GP -->|exonic & intronic| VC{is_variant_conserved}
       VP -->APP{aggregate_patho_prediction}
       GP -->|intronic| PMP{"parse_maxentscan_pred"}
       GP -->|intronic| PDP{"parse_dbscsnv_pred"}
       PMP -->ASP{aggregate_splicing_prediction}
       PDP -->ASP
       end
#+end_src

#+RESULTS:
[[file:prediction_tool_genotoscope.png]]
* Allele frequency rules
Handling which threshold is to be used, is handled in a completely different part of the code
So the function for each of the allele_frequency_rules only know where to look for the corresponding thresholds (e.g. BA1 uses BA1_threshold, etc)
I'll not account initially for different modes of inheritance as Damianos did
I can still add that later
#+begin_src mermaid :file allele_frequency_rules.png
flowchart LR
   popmax --> aaf{assess_allele_frequency_rule}
   subgraph assess-soasdfj
   cft{compare_frequency_to_threshold} --> ft[frequency_status]
   aaf -->|threshold & popmax| cft
   ft --> aaf
   end
   aaf --> is_rule_applicable
   aaf --> rule_comment
   aaf --> rule_strength
#+end_src

* PM1
Information needed: variant information, transcripts, critical region, hotspot, critical protein regions without bening variants
Generally regions applicable to PMs for missense variants
#+begin_src mermaid :file pm1_critical_region_refactored.png
flowchart LR
   D[data] --> CR{check_critical_region}
   GR[general_regions] --> CR
   SR[gene/disease_specific_regions] --> CR
   CR --> is_rule_applicable
   CR --> rule_comment
   CR --> rule_strength
  subgraph assess_critical_region
      CR --> GCR{check_general_critical_region}
      CR --> SCR{check_specific_critical_region}
      end
#+end_src

#+RESULTS:
[[file:pm1_critical_region_refactored.png]]

Generally the files used for this annotation should at best contain genomic location
In that case the whole transcript issue can be disregarded
Making the annotation a whole lot easier
Outsource the difficult task elsewhere
#+begin_src mermaid :file pm1_annotate_critical_region.png
flowchart LR
   FL[file_location] --> ACR{annotated_critical_regions}
   VD[variant_data] --> ACR
   ACR --> AVD[annotated_variant_data]
   subgraph annotate_critical_region
       ACR --> IV{intersect_file_with_variant}
       IV --> CS{check_strand}
       end
#+end_src

#+RESULTS:
[[file:pm1_annotate_critical_region.png]]
* PM4
#+begin_src mermaid :file assess_pm4_inframe.png
flowchart LR
   prot_len_diff_percent --> pi
   in_repetitive_region --> pi{assess_pm4_inframe}
   pi --> is_rule_applicable
   pi --> rule_strength
#+end_src

#+begin_src mermaid :file assess_pm4_stop_loss.png
flowchart LR
   is_stop_codon_in_3UTR --> sl
   prot_len_diff_percent --> sl{assess_pm4_stop_loss}
   sl --> is_rule_applicable
   sl --> rule_strength
#+end_src

** In repetitive region
#+begin_src mermaid :file check_repetitive_region.png
flowchart LR
   var_chr --> crr
   var_genomic_start --> crr
   var_genomic_stop --> crr
   var_gene_name --> crr
   repetitive_regions --> crr{check_repetitive_region}
   crr --> is_repetitive_region
#+end_src

#+RESULTS:
[[file:check_repetitive_region.png]]
** Protein length difference lost stop codon
#+begin_src mermaid :file protein_len_difference_stop_codon_lost.png
flowchart LR
   is_stop_codon_in_3UTR --> ptl
   ref_transcript --> ptl{get_protein_len_difference_stop_codon_lost}
   ptl --> prot_len_diff_percent
#+end_src

#+RESULTS:
[[file:protein_len_difference_stop_codon_lost.png]]
* BP3
#+begin_src mermaid :file assess_bp3.png
flowchart LR
   prot_len_diff_percent --> pi
   in_repetitive_region --> pi{assess_bp3}
   pi --> is_rule_applicable
   pi --> rule_strength
#+end_src

#+RESULTS:
[[file:assess_bp3.png]]

* PVS1
Information needed: sequence of variant
Transcripts affected by variant
Don't try and separate all the functions and refactor them here
Instead to begin with simply move the whole bunch to the annotation portion
Here it should be clearly defined though what input is needed for all of the separate functions
1. Sequence per transcript
2. Alternative start codons
3. Prediction of NMD
4. Assess exon skipping
5. Truncated exon significance
6. Protein length change
7. Premature termination codon
** Get position in transcript
The function  ~get_intron_offset~ is called ~parse_variant_intron_pos~ RefineLossofFunction
Information previously stored in ~variant_info~ object and ~transcript_info~ dictionary
I'd like to remove it, as I fell like it obstructs the clear picture of the flow of information in the tools
#+begin_src mermaid :file pvs1_get_variant_position_in_transcirpt.png
flowchart LR
   gvp{get_variant_position_in_transcirpt} --> exon_skipping
   gvp --> exon_affected_in_transcript
   gvp --> types_exon_skipped
   gvp --> variant_transcript_start
   gvp --> variant_transcript_stop
   rt[reference_transcript] --> gvp
   var_genomic_start --> gvp
   var_genomic_stop --> gvp
   var_hgvs --> gvp
   var_type --> gvp
   var_exon --> gvp
   subgraph get_variant_position_in_transcirpt
       gvp --> |if splice variant| gio{get_intron_offset}
       gvp --> |if not splice variant| fe{find_exon_by_var_pos}
       gio --> io[intron_offset]
       io --> aes{assess_exon_skipping}
       aes --> fe
       end
#+end_src

#+RESULTS:
[[file:pvs1_get_variant_position_in_transcirpt.png]]

*** Assess exon skipping
#+begin_src mermaid :file assess_exon_skipping.png
flowchart LR
   aes --> exon_skipping
   aes -->  exons_affected_in_transcript
   aes --> transcript_variant_start
   aes --> transcript_variant_stop
   aes --> types_exon_skipped
   intron_offset --> aes{assess_exon_skipping}
   variant_type --> aes
   transcript_exon --> aes
   var_hgvs --> aes
   genomic_start --> aes
   genomic_stop --> aes
#+end_src

#+RESULTS:
[[file:assess_exon_skipping.png]]

** Sequence
This will for now return sequence, skipped exons and difference in protein_length
#+begin_src mermaid :file pvs1_reconstruct_variant_coding_sequence.png
flowchart LR
   cvs --> variant_sequence
   cvs --> diff_len
   var_genomic_start --> cvs{contrsuct_variant_coding_sequence}
   var_genomic_stop --> cvs
   var_type --> cvs
   var_hgvs --> cvs
   var_transcript_id --> cvs
   exon_skipping --> cvs
   exons_affected_in_transcript --> cvs
   types_exon_skipped --> cvs
   variant_transcript_start --> cvs
   variant_transcript_stop --> cvs
#+end_src

#+RESULTS:
[[file:pvs1_reconstruct_variant_coding_sequence.png]]

** Prediction NMD
Gets transcript info and variant info
Variant info only needed for logging
#+begin_src mermaid :file pvs1_assess_NMD.png
flowchart LR
   nmd --> is_NMD
   faep --> NMD_affected_exons
   exon_skipping --> nmd{assess_NMD}
   exons_affected_in_transcript --> nmd
   types_exon_skipped --> nmd
   transcript_variant_start --> nmd
   transcript_variant_stop --> nmd
   variant_sequence --> nmd
   diff_len --> nmd
   var_type --> nmd
   subgraph assess_NMD
       nmd --> ssc{search_stop_codon}
       nmd --> faep{find_affected_exons_pos}
       end
#+end_src

#+RESULTS:
[[file:pvs1_assess_NMD.png]]
*** Note
Transcript_variant_start and transcript_variant_end are describing the position of the variant in the exon
This is either created by assess_exon_skipping function in case an exon is being skipped otherwise the variable is created from the find_exon_by_var_pos function
The former is used in construct_variant_seque
I find it difficult that the exons that the variant is skipping is described by the same variable as the variable that described which exon is affected by a variant when no exon is being skipped
** Refine PVS1 for start lost
#+begin_src mermaid :file pvs1_refine_start_lost.png
flowchart LR
   esc --> is_pvs1_start_lost
   esc --> pvs1_start_lost_strength
   is_alternative_start_codon --> esc{evaluate_start_codon}
   pathogenic_variant_between_start_and_start_alternative --> esc
#+end_src

#+RESULTS:
[[file:pvs1_refine_start_lost.png]]

** Find alternative start codon
#+begin_src mermaid :file pvs1_exists_alternative_start_codon.png
flowchart LR
   fasc{exists_alternative_start_codon} --> is_alternative_start_codon
   ref_transcript --> fasc
#+end_src

#+RESULTS:
[[file:pvs1_exists_alternative_start_codon.png]]

** Find pathogenic variants between original start codon and new start codon
#+begin_src mermaid :file pvs1_find_pathogenic_variant_between_start_and_alternative_start.png
flowchart LR
   csci --> fpv{find_pathogenic_variant_in_range}
   variant_sequence --> fas{find_alternative_start_codon}
   var_genomic_start --> fpv
   var_genomic_stop --> fpv
   var_chr --> fpv
   ref_transcript --> fpv
   fas --> csci[closest_start_codon_index]
   fpv --> pathogenic_variant_between_start_and_start_alternative
#+end_src

#+RESULTS:
[[file:pvs1_find_pathogenic_variant_between_start_and_alternative_start.png]]

** Refine PVS1 for splice site
#+begin_src mermaid :file pvs1_refine_splice_site.png
flowchart LR
   rss --> is_pvs1_splice_site
   rss --> pvs1_splice_site_strength
   var_type --> rss{refine_splice_site}
   var_hgvs --> rss
   exon_skipping --> rss
   types_exon_skipped --> rss
   is_reading_frame --> rss
   is_NMD --> rss
   transcript_affected_by_NMD_disease_relevant --> rss
   truncated_exon_relevant --> rss
   prot_len_diff_percentage --> rss
#+end_src

#+RESULTS:
[[file:pvs1_refine_splice_site.png]]

*** Note
In the original code the function ~evaluate_skipping_start_codon_exon~
This is not part of the general recommendations for PVS1
The output from that function is not returned
** Assess reading frame
#+begin_src mermaid :file pvs1_assess_reading_frame.png
flowchart LR
   diff_len --> arfp{assess_reading_frame_preservation}
   arfp --> is_reading_frame
#+end_src

#+RESULTS:
[[file:pvs1_assess_reading_frame.png]]

** Refine PVS1 for nonsense and frameshift
#+begin_src mermaid : :file pvs1_refine_nonsense_frameshift.png
flowchart LR
   rnf{refine_nonsense_frameshift} --> is_pvs1_nonsense_frameshift
   rnf --> pvs1_nonsense_frameshift_strength
   is_NMD --> rnf
   transcript_affected_by_NMD_disease_relevant --> rnf
   truncated_exon_relevant --> rnf
   prot_len_diff_percentage --> rnf
#+end_src

#+RESULTS:
[[file:pvs1_refine_nonsense_frameshift.png]]

** Transcript relevance
exons_disease_relevant_transcripts is from literature
Research how Damianos created that
Look into alternatives to creating that
E.g. all transcripts of HBOC genes that produced functional proteins
#+begin_src mermaid :file pvs1_assess_relevance_of_transcript.png
flowchart LR
   art --> transcript_affected_by_NMD_disease_relevant
   var_chr --> art
   NMD_affected_exons --> art{assess_transcript_relevance}
   exons_disease_relevant_transcripts --> art
#+end_src

#+RESULTS:
[[file:pvs1_assess_relevance_of_transcript.png]]

Wouldn't so
** Exon relevance
#+begin_src mermaid :file pvs1_assess_relevance_of_exon.png
flowchart LR
   aer --> truncated_exon_relevant
   var_chr --> aer
   ref_transcript --> aer
   NMD_affected_exons --> aer{assess_truncated_exon_relevance}
   prot_domains --> aer
   critical_protein_regions --> aer
   exons_disease_relevant_transcripts --> aer
#+end_src

#+RESULTS:
[[file:pvs1_assess_relevance_of_exon.png]]

** Protein length difference
#+begin_src mermaid :file pvs1_get_protein_len_difference.png
flowchart LR
   cpl --> prot_len_diff_percent
   variant_sequence --> cpl{calculate_protein_length}
   reference_transcript --> cpl
#+end_src

#+RESULTS:
[[file:pvs1_get_protein_len_difference.png]]

** Combine PVS1 refinement results
#+begin_src mermaid :file combine_pvs1_refinement_results.png
flowchart LR
   is_pvs1_nonsense_frameshift --> cp
   pvs1_nonsense_frameshift_strength --> cp
   is_pvs1_splice_site --> cp
   pvs1_splice_site_strength --> cp
   is_pvs1_start_lost --> cp
   pvs1_start_lost_strength --> cp{integrate_rules}
   cp --> is_rule_applicable
   cp --> rule_comment
   cp --> rule_strength
#+end_src

** TODO Think on how I want to handle data types
Specifically the variant_info class and the dictionary used to transport variant information
Those I do not really want to be using for my work
Therefore, they'll have to be replaced and the code refactored in order for the code to work with the new data structures
Though that should very much be a second though
For the first implementation of the code there should be no thoughts on these data structures
* Annotate ClinVar
Three separate columns will have to be generated
1. Same amino acid change in location
2. Different amino acid change in same location
** Assess PS1
#+begin_src mermaid :file Clinvar_assess_ps1.png
flowchart LR
   codon_genomic_pos --> aps
   codon_seq_ref --> aps
   prot_start --> aps
   amino_ref --> aps
   amino_obs --> aps
   clinvar_entries_per_transcript --> aps{assess_ps1}
   aps --> is_rule_applicable
   aps --> rule_strength
   aps --> rule_comment
#+end_src

#+RESULTS:
[[file:Clinvar_assess_ps1.png]]

** Assess PM5
#+begin_src mermaid :file Clinvar_assess_pm5.png
flowchart LR
   codon_genomic_pos --> apm
   prot_start --> apm
   var_genomic_start --> apm
   codon_seq_ref -> apm
   clinvar_entries_per_transcript --> apm{assess_pm5}
   apm --> is_rule_applicable
   apm --> rule_strength
   apm --> rule_comment
#+end_src

#+RESULTS:
[[file:Clinvar_assess_pm5.png]]

** Variant codon information
Creates the below described transcript_var_codon_info object
#+begin_src mermaid :file Clinvar_transcript_var_codon_information.png
flowchart LR
   var_genomic_start --> ct
   var_obs_base --> ct
   var_transcript_id --> ct
   var_hgvs --> ct{create_transcript_var_codon_info}
   ct --> var_start
   ct --> codon_genomic_pos
   ct --> codon_coding_pos
   ct --> codon_intersect_intron_at
   ct --> var_strand
   ct --> codon_seq_ref
   ct --> codon_seq_obs
   ct --> prot_start
   ct --> amino_ref
   ct --> amino_obs
#+end_src

#+RESULTS:
[[file:Clinvar_transcript_var_codon_information.png]]

** Information class ~transcripts_var_codon_info~
- var_start
  cDNA location of variants
  Start location in case multiple bases are affected
  E.g. 1
- genomic_pos
  List of all positions of the codon
  Position in genomic DNA
  E.g. [123,124,125]
- coding_pos
  List of all positions of the codon
  Position in cDNA
  E.g. [1,2,3]
- intersect_intron_at
  Checks which part of the codon intersects with an intron
- strand
  Strand transcript is located on
  "+" or "-"
- seq_ref
  Sequence of reference codon
  E.g. "ATC"
- seq_obs
  Sequence of observed codon
  E.g. "AAC"
- prot_start
  Position of change amino acid in protein
  E.g. "112"
- amino_ref
  Reference amino acid in 3 and 1 letter code
  E.g. ["A", "Ala"]
- amino_obs
  Observed amino acid in 3 and 1 letter code
  E.g.["W", "Trp"]
** Create ClinVar
#+begin_src mermaid :file Clinvar_create_clinvar.png
flowchart LR
   var_chr --> cc
   var_transcript_id --> cc
   ref_transcript --> cc
   codon_genomic_pos --> cc
   codon_intersect_intron_at --> cc
   minimum_number_stars --> cc{create_clinvar}
   cc --> clinvar_entries_per_transcript
#+end_src
* AssignACMG
#+begin_src mermaid :file assig_acmg.png
flowchart LR
   is_rule_applicable --> aa
   rules_strength --> aa{assign_acmg}
   ca --> classification
   ca --> classification_comment
   subgraph assign_acmg
       aa --> ci{check_incopatible_rule_combinations}
       aa --> srs{summarise_rules_by_strength}
       srs --> rbs[rules_by_strength]
       rbs --> ca{classify_acmg}
       end
#+end_src

#+RESULTS:
[[file:assig_acmg.png]]
* Calculate pathogenicity probability
#+begin_src mermaid :file calculate_pathogenicity_probability.png
flowchart LR
   rules_by_strength --> cp
   odds_pathogenicity_very_strong --> cp
   pathogenicity_prior --> cp
   scaling_factor --> cp{calculate_pathogenicity_probability}
   cp --> posterior_pathogenicity_probability
#+end_src

#+RESULTS:
[[file:calculate_pathogenicity_probability.png]]

* Transcripts_info
This is a dataframe created by Daminaos in which he is saving the information generated on transcript level for the different variants
- gene_name
  Gene name
  E.g. BRCA1
- transcript_id
  Transcript ID (shortened)
  E.g. ENST00000380152
- type_variant
  Is type list
  Most likely will only contain one item but can also contain multiple
  E.g. [missense_variant]
- exon
  contains exon with 2 numbers
  E.g. "exon11/27"
  What does that mean?
- var_coding
  Contains a hgvs_parser object
  This object describes the change to the variant that occurs
- var_seq
  Sequence of deletion or insertion as found in HGVS nomenclature
  Check if that is true
- var_protein
  Contains change in protein sequence
  E.g. "Lys1025Glu"
** TODO There seems to be an error in the construction of var_seq in case of delins
If I understand correctly del_seq has to always be empty
