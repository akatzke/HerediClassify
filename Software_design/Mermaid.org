#+title: Mermaid

* General information
Code for visualising software design in mermaid
* Variant classification overview
#+begin_src mermaid :file overview.png
flowchart LR
    DB[(Database)] -->|Import| RD[Raw data]
    C["Configuration"] --> CI{"Configuration import"}
    CR["Configuration
   rules"] --> CIR{"Configuration import
   rules"}
    CL --> |Export| Output
    subgraph Variant_classification_tool
        CI --> T[Thresholds]
        RD -->DP{Data processing}
        DP --> PD[Processed data]
        CIR --> PL[Data process list]
        CIR --> RL[Rule list]
        PL --> DP
        PD --> CL{Classification}
        RL --> CL
        T --> DP
    end
#+end_src

#+RESULTS:
[[file:overview.png]]

* Configuration import
#+begin_src mermaid :file configuration_import_rules.png
flowchart LR
    CF[Configuration rules] -->I{import}
    CS --> RE[Error]
    FR --> DPL["Data processing
    set"]
    FR --> RL[Rule set]
    subgraph Configuration_import
        I --> C[Configuration]
        C --> FR{find_rule_in_dict}
        RD[Rule dictionary] -->FR
        FR --> IS{insert_into_set}
        IS --> CS{check_set}
        end
#+end_src

#+RESULTS:
[[file:configuration_import_rules.png]]
** Note
For the data processing the variant is important too
So for certain variant types some annotations are not necessary
E.g. the coding sequence reconstruction is only necessary for a subset of variants and very processing intensive
At this point in some manner the variant_type should be checked as well?
* Prediction tools
** Prediction tools refactored
#+begin_src mermaid :file predicition_tool.png
flowchart LR
   T[threshold] --> GP{get_prediction}
   D[data] --> GP
   TL[tool_list] --> GP
   PT[prediction_type] --> GP
   subgraph prediction_tools
       GP --> 1T{assess_one_threshold}
       GP --> 2T{assess_two_threshold}
       GP --> APR["aggregate prediction
       results"]
       end
#+end_src

#+RESULTS:
[[file:predicition_tool.png]]
** GenOtoScope
Decision on what prediction tool is to be used is based on variant type
Exonic variants only get pathogenictiy scores and conservation
Intronic and synonymous variants get
#+begin_src mermaid :file prediction_tool_genotoscope.png
flowchart LR
   VT["variant type
   exonic, intronic
   or synonymous"] --> GP{get_prediction}
   T[threshold] --> GP
   APP -->ER["exonic result"]
   VC --> ER
   APP --> IR["intronic result"]
   ASP -->IR
   VC --> IR
   APP --> SR["synonymous result"]
   VC --> SR
   ASP --> SR
   subgraph assess_pp3_bp4
       GP -->|exonic & intronic| VP{is_variant_pathogenic}
       GP -->|exonic & intronic| VC{is_variant_conserved}
       VP -->APP{aggregate_patho_prediction}
       GP -->|intronic| PMP{"parse_maxentscan_pred"}
       GP -->|intronic| PDP{"parse_dbscsnv_pred"}
       PMP -->ASP{aggregate_splicing_prediction}
       PDP -->ASP
       end
#+end_src

#+RESULTS:
[[file:prediction_tool_genotoscope.png]]
* PM1
Information needed: variant information, transcripts, critical region, hotspot, critical protein regions without bening variants
Generally regions applicable to PMs for missense variants
#+begin_src mermaid :file critical_region_refactored.png
flowchart LR
   D[data] --> CR{check_critical_region}
   GR[general_regions] --> CR
   SR[gene/disease_specific_regions] --> CR
   CR --> R[Result]
  subgraph assess_critical_region
      CR --> GCR{check_general_critical_region}
      CR --> SCR{check_specific_critical_region}
      end
#+end_src

#+RESULTS:
[[file:critical_region_refactored.png]]

Generally the files used for this annotation should at best contain genomic location
In that case the whole transcript issue can be disregarded
Making the annotation a whole lot easier
Outsource the difficult task elsewhere
#+begin_src mermaid :file annotate_critical_region.png
flowchart LR
   FL[file_location] --> ACR{annotated_critical_regions}
   VD[variant_data] --> ACR
   ACR --> AVD[annotated_variant_data]
   subgraph annotate_critical_region
       ACR --> IV{intersect_file_with_variant}
       IV --> CS{check_strand}
       end
#+end_src

#+RESULTS:
[[file:annotate_critical_region.png]]
* PVS1
Information needed: sequence of variant
Transcripts affected by variant
Don't try and separate all the functions and refactor them here
Instead to begin with simply move the whole bunch to the annotation portion
Here it should be clearly defined though what input is needed for all of the separate functions
1. Sequence per transcript
2. Alternative start codons
3. Prediction of NMD
4. Assess exon skipping
5. Truncated exon significance
6. Protein length change
7. Premature termination codon
** Get position in transcript
The function  ~get_intron_offset~ is called ~parse_variant_intron_pos~ RefineLossofFunction
#+begin_src mermaid :file get_variant_position_in_transcirpt.png
flowchart LR
   ti[transcript_info] --> gvp{get_variant_position_in_transcirpt}
   gvp --> exon_skipping
   gvp --> exon_affected_in_transcript
   gvp --> types_exon_skipped
   gvp --> variant_transcript_start
   gvp --> variant_transcript_stop
   rt[reference_transcript] --> gvp
   vp[variant_position] --> gvp
   subgraph get_variant_position_in_transcirpt
       gvp --> |if splice variant| gio{get_intron_offset}
       gvp --> |if not splice variant| fe{find_exon_by_var_pos}
       gio --> io[intron_offset]
       io --> aes{assess_exon_skipping}
       aes --> fe
       end
#+end_src

#+RESULTS:
[[file:get_variant_position_in_transcirpt.png]]

*** Assess exon skipping
#+begin_src mermaid :file assess_exon_skipping.png
flowchart LR
   aes --> exon_skipping
   aes -->  exons_affected_in_transcript
   aes --> transcript_variant_start
   aes --> transcript_variant_stop
   aes --> types_exon_skipped
   intron_offset --> aes{assess_exon_skipping}
   variant_type --> aes
   transcript_exon --> aes
   var_hgvs --> aes
   genomic_start --> aes
   genomic_stop --> aes
#+end_src

#+RESULTS:
[[file:assess_exon_skipping.png]]

** Sequence
This will for now return sequence, skipped exons and difference in protein_length
#+begin_src mermaid :file reconstruct_variant_coding_sequence.png
flowchart LR
   cvs --> variant_sequence
   cvs --> diff_len
   var_genomic_start --> cvs{contrsuct_variant_coding_sequence}
   var_genomic_stop --> cvs
   var_type --> cvs
   var_hgvs --> cvs
   var_transcript_id --> cvs
   exon_skipping --> cvs
   exons_affected_in_transcript --> cvs
   types_exon_skipped --> cvs
   transcript_variant_start --> cvs
   transcript_variant_stop --> cvs
#+end_src

#+RESULTS:
[[file:reconstruct_variant_coding_sequence.png]]

** Prediction NMD
Gets transcript info and variant info
Variant info only needed for logging
#+begin_src mermaid :file assess_NMD.png
flowchart LR
   nmd --> NMD_status
   faep --> NMD_affected_exons
   exon_skipping --> nmd{assess_NMD}
   exons_affected_in_transcript --> nmd
   types_exon_skipped --> nmd
   transcript_variant_start --> nmd
   transcript_variant_stop --> nmd
   variant_sequence --> nmd
   diff_len --> nmd
   var_type --> nmd
   subgraph assess_NMD
       nmd --> ssc{search_stop_codon}
       nmd --> faep{find_affected_exons_pos}
       end
#+end_src

#+RESULTS:
[[file:assess_NMD.png]]
*** Note
Transcript_variant_start and transcript_variant_end are describing the position of the variant in the exon
This is either created by assess_exon_skipping function in case an exon is being skipped otherwise the variable is created from the find_exon_by_var_pos function
The former is used in construct_variant_seque
I find it difficult that the exons that the variant is skipping is described by the same variable as the variable that described which exon is affected by a variant when no exon is being skipped
** Refine PVS1 for start lost
#+begin_src mermaid :file refine_start_lost.png
flowchart LR
   esc --> pvs1_start_lost_status
   esc --> pvs1_start_lost_strength
   exist_alternative_start_codon --> esc{evaluate_start_codon}
   pathogenic_variant_between_start_loss_and_start_alternative --> esc
#+end_src

#+RESULTS:
[[file:refine_start_lost.png]]

** Find alternative start codon
** Find pathogenic variants between original start codon and new start codon
** Refine PVS1 for splice site
#+begin_src mermaid :file refine_splice_site.png
flowchart LR
   rss --> pvs1_splice_site_status
   rss --> pvs1_splice_site_strength
   var_type --> rss{refine_splice_site}
   var_hgvs --> rss
   exon_skipping --> rss
   types_exon_skipped --> rss
   preservation_of_reading_frame --> rss
   NMD_status --> rss
   transcript_affected_by_NMD_disease_relevant --> rss
   truncated_exon_relevant --> rss
   prot_len_diff --> rss
#+end_src

#+RESULTS:
[[file:refine_splice_site.png]]
*** Note
In the original code the function ~evaluate_skipping_start_codon_exon~
This is not part of the general recommendations for PVS1
The output from that function is not returned
** Refine PVS1 for nonsense and frameshift
#+begin_src mermaid : :file refine_nonsense_frameshift.png
flowchart LR
   rnf{refine_nonsense_frameshift} --> pvs1_nonsense_frameshift_status
   rnf --> pvs1_nonsense_frameshift_strength
   NMD_status --> rnf
   transcript_affected_by_NMD_disease_relevant --> rss
   truncated_exon_relevant --> rss
   prot_len_diff --> rss
#+end_src
** Aggregate subrules
#+begin_src mermaid :file aggregate_subrules.png
   cr --> pvs1_strength
   cr --> pvs1_status
   cr --> csft{is_any_subrule_true}
   csft --> {get_highest_strength}
   rule_status --> cr
   rule_strengths --> cr
#+end_src
** TODO Think on how I want to handle data types
Specifically the variant_info class and the dictionary used to transport variant information
Those I do not really want to be using for my work
Therefore, they'll have to be replaced and the code refactored in order for the code to work with the new data structures
Though that should very much be a second though
For the first implementation of the code there should be no thoughts on these data structures
* Annotate ClinVar
Three separate columns will have to be generated
1. Same amino acid change in location
2. Different amino acid change in same location
3.
#+begin_src mermaid :file

#+end_src
* Transcripts_info
This is a dataframe created by Daminaos in which he is saving the information generated on transcript level for the different variants
- gene_name
  Gene name
  E.g. BRCA1
- transcript_id
  Transcript ID (shortened)
  E.g. ENST00000380152
- type_variant
  Is type list
  Most likely will only contain one item but can also contain multiple
  E.g. [missense_variant]
- exon
  contains exon with 2 numbers
  E.g. "exon11/27"
  What does that mean?
- var_coding
  Contains a hgvs_parser object
  This object describes the change to the variant that occurs
- var_seq
  Sequence of deletion or insertion as found in HGVS nomenclature
  Check if that is true
- var_protein
  Contains change in protein sequence
  E.g. "Lys1025Glu"
** TODO There seems to be an error in the construction of var_seq in case of delins
If I understand correctly del_seq has to always be empty
